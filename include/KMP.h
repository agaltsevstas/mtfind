#pragma once


#include <functional>
#include <string>
#include <vector>


/*
 Statefull класс из-за рассчета маски
 Алгоритм Кнута — Морриса — Пратта (KMP)
 Time: O(n+m) - для худшего и лучшего случаев, где n — длина строки, m — длина подстроки.
 Memory: O(m), где m — длина подстроки.
 
 Идея алгоритма KMP: всякий раз, когда обнаруживается несовпадение символов (после нескольких совпадений), то уже известны некоторые символы в тексте следующего окна. Воспользовавшись этой информации, можно избежать лишних сопоставлений символов, которые в любом случае совпадут.
 
 Алгоритм KMP предварительно обрабатывает mask и создает вспомогательный Longest prefix-suffix (lps) такого же размера как и маска, который используется для пропуска символов при сопоставлении.
 Имя lps указывает на самый длинный правильный префикс, который также является суффиксом. Правильный префикс — это префикс с целой строкой, которая не допускается. Например, префиксами «ABC» являются «», «A», «AB» и «ABC». Правильными префиксами являются «», «A» и «AB». Суффиксами строки являются «», «C», «BC» и «ABC».
 */
class KMP
{
    using Handle = std::function<void(uint64_t column, std::string&& match)>;
public:
    KMP(const std::string& mask);
    
    /* Вычисление самого длинного значения префикса-суффикса (lps).
     Для подстроки «AAAA» lps = [0, 1, 2, 3]
     Для подстроки «ABCDE» lps = [0, 0, 0, 0, 0]
     Для подстркои «AABAACAABAA» lps = [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]
     Для подстроки «AAACAAAAAC» lps = [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]
     Для подстроки «AAABAAA» lps = [0, 1, 2, 0, 1, 2, 3]
     */
    void CalculateLPS();
    
    // Time: O(n+m), где n — длина строки, m — длина подстроки,
    // Memory: O(m)
    void Search(const std::string& str, const Handle& handle = nullptr);
    
private:
    const std::string _mask;
    std::vector<uint64_t> _lps; // Longest prefix-suffix
};
