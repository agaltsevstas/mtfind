# Тестовое задание компании Optimacros

## Задача
Написать программу mtfind, производящую поиск подстроки в текстовом файле
по маске с использованием многопоточности. <br>
Маска - это строка, где "?" обозначает любой символ. <br>
Программа принимает в качестве параметров командной строки:
1. Имя текстового файла, в котором должен идти поиск (размер файла - до 1Гб).
2. Маску для поиска, в кавычках. Максимальная длина маски 1000 символов.

Вывод программы должен быть в следующем формате:
- На первой строке - количество найденных вхождений.
- Далее информация о каждом вхождении, каждое на отдельной строке, через пробел: номер строки, позиция в строке, само найденное вхождение.
- Порядок вывода найденных вхождений должен совпадать с их порядком в файле.
- Вся нумерация ведется начиная с 1 (делаем программу для обычных людей).

### Дополнения:
- В текстовом файле кодировка только 7-bit ASCII.
- Поиск с учетом регистра.
- Каждое вхождение может быть только на одной строке. Маска не может содержать символа перевода строки.
- Найденные вхождения не должны пересекаться. Если в файле есть пересекающиеся вхождения то нужно вывести одно из них (любое).
- Пробелы и разделители участвуют в поиске наравне с другими символами.
- Можно использовать STL, Boost, возможности С++1x.
- Многопоточность нужно использовать обязательно. Однопоточные решения засчитываться не будут.
- Серьезным плюсом будет разделение работы между потоками равномерно вне зависимости от количества строк во входном файле.
- Решение представить в виде архива с исходным кодом и проектом CMake или Visual Studio (либо в виде ссылки на онлайн Git-репозиторий).
- Код должен компилироваться в GCC или MSVC.

#### ПРИМЕР
Файл `input.txt`:
```txt
I've paid my dues
Time after time.
I've done my sentence
But committed no crime.
And bad mistakes ?
I've made a few.
I've had my share of sand kicked in my face
But I've come through.
```
Запуск программы: `mtfind.exe input.txt "?ad"`
#### Ожидаемый результат:
```txt
3
5 5 bad
6 6 mad
7 6 had
```

#### Критерии оценки решения:
- Правильность выдаваемых результатов.
- Качество и читабельность кода, легкость дальнейшего развития и поддержки.
- Скорость работы и потребление памяти.

Все критерии одинаково важны.

## Производительность достигается за счет:

### Асинхронность
Использование для обработки данных после чтения. <br>
Минусы: плохо будет работать с одной строкой или с очень маленькими строками.
 
### Алгоритмическая 
Использование алгоритма Алгоритм Кнута — Морриса — Пратта (KMP), т.к. он лучше по времени для худшего и лучшего случаев. <br>
Time: O(n+m) - для худшего и лучшего случаев, где n — длина строки, m — длина подстроки. <br>
Memory: O(m), где m — длина подстроки.
 
Другие алгоритмы, которые не подошли:
1. Алгоритм Бойера — Мура - хуже работает. <br>
Time: O(n+m) - лучший случай, O(n*m) - хуший случай, где n — длина строки, m — длина подстроки.
 
2. Алгоритм Рабина — Карпа - не подошел из-за того, что для строки вычисляется хэш-значение, поэтому для "?" обозначающий любой символ - этот алгоритм не подойдет. <br>
Time: O(n+m) - лучший случай, O(n*m) - хуший случай, где n — длина строки, m — длина подстроки. <br>
Memory: O(m), где m — длина подстроки.

### Параллельность 
Параллельное чтение файла по частям с 1 потоком и экономия памяти: после обработки данных, данные удаляются. Если использовать многопоточное чтение, то требуются большие вычислительные мощности: если чтение данных медленнее относительно обработки данных, то параллелить смысла нет. Диск, с которого читают данные, должен работать быстрее процессора (CPU), иначе многопоточное чтение не имеет смысла.
 
### RAII
Передача данных с помощью умных указателей (RAII) и экономия памяти при копировании. Опасность передачи объекта по ссылке: в одном классе время жизни объекта будет меньше, чем в другом классе: при выходе из зоны видимости (стека) будет вызван деструктор, поэтому будет UB.
 
### Структурная
Хранение результатов лучше в векторе: чтение в векторе быстрее, чем например в list, хотя временная сложность одинаковая (Time: O(n)).
1. в vector нет переходов по указателям и разыменований указателей.
2. vector - непрерывный блок и элементы находятся последовательно в памяти, расположенный в куче, он может полностью помещаться в кэш. <br>
   list - данные хранятся в памяти НЕпоследовательно, поэтому элементы разбросаны по всей памяти -> плохая локальность -> много дорогостоящих промахов в кэше процессора (cache miss).
3. проблема фрагментации памяти. Выделение памяти происходит блоками — непрерывными фрагментами оперативной памяти (таким образом, каждый блок — это несколько идущих подряд байт). В какой-то момент в куче попросту может не оказаться блока подходящего размера и, даже если свободная память достаточна для размещения объекта, операция выделения памяти окончится неудачей.

## Что можно было улучшить:
- передавать данные между потоками не с помощью очереди (Queue), а в другом контейнере, чтобы потом можно распараллелить обработку данных с помощью std::execution::par или OpenMP или TBB;
- сделать обработку больших данных в Queue с более оптимальным счетчиком, чем hardware_concurrency, для маленьких строк или при маленьком кол-ве строк не использовать счетчик вообще.
